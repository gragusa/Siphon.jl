<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Functions · Filthy.jl</title><meta name="title" content="Core Functions · Filthy.jl"/><meta property="og:title" content="Core Functions · Filthy.jl"/><meta property="twitter:title" content="Core Functions · Filthy.jl"/><meta name="description" content="Documentation for Filthy.jl."/><meta property="og:description" content="Documentation for Filthy.jl."/><meta property="twitter:description" content="Documentation for Filthy.jl."/><meta property="og:url" content="https://gragusa.github.io/Filthy.jl/stable/api/core.html"/><meta property="twitter:url" content="https://gragusa.github.io/Filthy.jl/stable/api/core.html"/><link rel="canonical" href="https://gragusa.github.io/Filthy.jl/stable/api/core.html"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Filthy.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/getting_started.html">Getting Started</a></li><li><a class="tocitem" href="../tutorials/custom_models.html">Custom Models</a></li><li><a class="tocitem" href="../tutorials/dynamic_factor.html">Dynamic Factor Models</a></li><li><a class="tocitem" href="../tutorials/estimation_methods.html">Estimation Methods</a></li><li><a class="tocitem" href="../tutorials/transformations.html">Parameter Transformations</a></li><li><a class="tocitem" href="../tutorials/visualization.html">Visualization</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href="core.html">Core Functions</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Kalman-Filter"><span>Kalman Filter</span></a></li><li><a class="tocitem" href="#Kalman-Smoother"><span>Kalman Smoother</span></a></li><li><a class="tocitem" href="#Prediction-and-Forecasting"><span>Prediction and Forecasting</span></a></li><li><a class="tocitem" href="#Missing-Data-Utilities"><span>Missing Data Utilities</span></a></li><li><a class="tocitem" href="#StaticArrays-Utilities"><span>StaticArrays Utilities</span></a></li></ul></li><li><a class="tocitem" href="dsl.html">DSL &amp; Templates</a></li><li><a class="tocitem" href="matrix_helpers.html">Matrix Helpers</a></li><li><a class="tocitem" href="optimization.html">Optimization &amp; Bayesian</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="core.html">Core Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="core.html">Core Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gragusa/Filthy.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gragusa/Filthy.jl/blob/master/docs/src/api/core.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h1><p>This page documents the core Kalman filtering and smoothing functions.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Filthy.KFParms"><a class="docstring-binding" href="#Filthy.KFParms"><code>Filthy.KFParms</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KFParms{Zt, Ht, Tt, Rt, Qt}</code></pre><p>State-space model parameters for the Kalman filter.</p><p><strong>State Space Model</strong></p><pre><code class="language-julia hljs">y_t = Z * α_t + ε_t,    ε_t ~ N(0, H)
α_{t+1} = T * α_t + R * η_t,    η_t ~ N(0, Q)</code></pre><p><strong>Fields</strong></p><ul><li><code>Z</code>: Observation matrix (p × m)</li><li><code>H</code>: Observation noise covariance (p × p)</li><li><code>T</code>: State transition matrix (m × m)</li><li><code>R</code>: State noise selection matrix (m × r)</li><li><code>Q</code>: State noise covariance (r × r)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/types.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.KFParms_static"><a class="docstring-binding" href="#Filthy.KFParms_static"><code>Filthy.KFParms_static</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">KFParms_static(Z, H, T, R, Q)</code></pre><p>Create KFParms with automatic StaticArrays conversion for small matrices.</p><p>Equivalent to <code>KFParms(to_static_if_small(Z), ...)</code> for all parameters. Use this for potential performance gains when state/observation dimensions are small (≤ 13).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># These become SMatrix automatically
p = KFParms_static([1.0;;], [1.0;;], [1.0;;], [1.0;;], [1.0;;])
typeof(p.Z)  # SMatrix{1, 1, Float64, 1}

# Large matrices stay as Matrix
p = KFParms_static(rand(20,20), rand(20,20), rand(20,20), rand(20,20), rand(20,20))
typeof(p.Z)  # Matrix{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/types.jl#L71-L89">source</a></section></details></article><h2 id="Kalman-Filter"><a class="docs-heading-anchor" href="#Kalman-Filter">Kalman Filter</a><a id="Kalman-Filter-1"></a><a class="docs-heading-anchor-permalink" href="#Kalman-Filter" title="Permalink"></a></h2><h3 id="Log-Likelihood"><a class="docs-heading-anchor" href="#Log-Likelihood">Log-Likelihood</a><a id="Log-Likelihood-1"></a><a class="docs-heading-anchor-permalink" href="#Log-Likelihood" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Filthy.kalman_loglik"><a class="docstring-binding" href="#Filthy.kalman_loglik"><code>Filthy.kalman_loglik</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kalman_loglik(p::KFParms, y, a1, P1) -&gt; loglik</code></pre><p>Compute the log-likelihood of a linear Gaussian state space model using the Kalman filter.</p><p>This is an AD-compatible implementation that:</p><ul><li>Uses pure functional operations (no in-place mutations)</li><li>Avoids try-catch blocks</li><li>Propagates element types correctly for automatic differentiation</li><li>Handles missing observations (NaN values)</li></ul><p><strong>Arguments</strong></p><ul><li><code>p::KFParms</code>: State space parameters (Z, H, T, R, Q)</li><li><code>y::AbstractMatrix</code>: Observations (p × n matrix, where p is observation dim, n is time).                      Missing values should be marked as <code>NaN</code>.</li><li><code>a1::AbstractVector</code>: Initial state mean</li><li><code>P1::AbstractMatrix</code>: Initial state covariance</li></ul><p><strong>Returns</strong></p><ul><li><code>loglik::Real</code>: Log-likelihood of the observed (non-missing) data</li></ul><p><strong>State Space Model</strong></p><pre><code class="language-julia hljs">y_t = Z * α_t + ε_t,    ε_t ~ N(0, H)
α_{t+1} = T * α_t + R * η_t,    η_t ~ N(0, Q)</code></pre><p><strong>Missing Data</strong></p><p>When <code>y[:, t]</code> contains any NaN, the observation is treated as missing. The filter skips the measurement update and propagates the state:     a<em>{t+1} = T * a</em>t     P<em>{t+1} = T * P</em>t * T&#39; + R * Q * R&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/filter_ad.jl#L47-L79">source</a></section><section><div><pre><code class="language-julia hljs">kalman_loglik(p::KFParms{&lt;:SMatrix,...}, y, a1::SVector, P1::SMatrix) -&gt; loglik</code></pre><p>Fully static specialization of Kalman filter log-likelihood for small state dimensions.</p><p>When all system matrices in KFParms are SMatrix and the initial state (a1, P1) are SVector/SMatrix, this method keeps all intermediate computations static, avoiding heap allocations in the inner loop.</p><p>This provides significant speedup (3x-17x depending on dimensions) for models where both state dimension m and observation dimension p are small (≤ STATIC_THRESHOLD).</p><p><strong>Performance Notes</strong></p><ul><li>Zero allocations in the inner loop</li><li>Enables loop unrolling and SIMD vectorization</li><li>Best for m ≤ 8 and p ≤ 5 (speedup decreases for larger dimensions)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/filter_ad.jl#L181-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.kalman_loglik_scalar"><a class="docstring-binding" href="#Filthy.kalman_loglik_scalar"><code>Filthy.kalman_loglik_scalar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kalman_loglik_scalar(Z, H, T, R, Q, a1, P1, y) -&gt; loglik</code></pre><p>Scalar (univariate) version of the Kalman filter log-likelihood.</p><p>Optimized for the common case of scalar state and observation. Handles missing observations marked as NaN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/filter_ad.jl#L293-L300">source</a></section></details></article><h3 id="Full-Filter-Output"><a class="docs-heading-anchor" href="#Full-Filter-Output">Full Filter Output</a><a id="Full-Filter-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Filter-Output" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Filthy.kalman_filter_full"><a class="docstring-binding" href="#Filthy.kalman_filter_full"><code>Filthy.kalman_filter_full</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kalman_filter_full(p::KFParms, y, a1, P1) -&gt; KalmanFilterResult</code></pre><p>Run full Kalman filter returning both predicted and filtered states.</p><p>For <code>n</code> observations, returns <code>n</code> time points:</p><ul><li><code>at[:, t]</code> = E[αₜ | y₁:ₜ₋₁] (predicted state before seeing yₜ)</li><li><code>att[:, t]</code> = E[αₜ | y₁:ₜ] (filtered state after seeing yₜ)</li><li><code>Pt[:, :, t]</code> = Var[αₜ | y₁:ₜ₋₁] (predicted covariance)</li><li><code>Ptt[:, :, t]</code> = Var[αₜ | y₁:ₜ] (filtered covariance)</li></ul><p>Returns a <code>KalmanFilterResult</code> with:</p><ul><li><code>loglik</code>: Log-likelihood (of non-missing observations)</li><li><code>at</code>: Predicted state means (m × n)</li><li><code>Pt</code>: Predicted state covariances (m × m × n)</li><li><code>att</code>: Filtered state means (m × n)</li><li><code>Ptt</code>: Filtered state covariances (m × m × n)</li><li><code>vt</code>: Innovations (p × n), NaN for missing observations</li><li><code>Ft</code>: Innovation covariances (p × p × n)</li><li><code>Kt</code>: Kalman gains (m × p × n), zero for missing observations</li><li><code>missing_mask</code>: BitVector indicating missing observations (length n)</li></ul><p>Use accessor methods: <code>predicted_states</code>, <code>filtered_states</code>, <code>variances_predicted_states</code>, <code>variances_filtered_states</code>, <code>prediction_errors</code>, <code>variances_prediction_errors</code>, <code>kalman_gains</code>, <code>loglikelihood</code>.</p><p><strong>Missing Data</strong></p><p>When <code>y[:, t]</code> contains any NaN, the observation is treated as missing. The filter skips the measurement update and propagates the state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/filter_ad.jl#L392-L421">source</a></section><section><div><pre><code class="language-julia hljs">kalman_filter_full(p::KFParms{&lt;:SMatrix,...}, y, a1::SVector, P1::SMatrix) -&gt; KalmanFilterResult</code></pre><p>Fully static specialization of Kalman filter for small state dimensions.</p><p>When all system matrices in KFParms are SMatrix and the initial state (a1, P1) are SVector/SMatrix, this method uses static arithmetic in the inner loop while storing results in regular arrays (which must be heap-allocated for the full filter).</p><p>The speedup comes from keeping intermediate state computations (a, P, v, F, K) as StaticArrays, avoiding temporary allocations within each iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/filter_ad.jl#L534-L545">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.kalman_filter_full_scalar"><a class="docstring-binding" href="#Filthy.kalman_filter_full_scalar"><code>Filthy.kalman_filter_full_scalar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kalman_filter_full_scalar(Z, H, T, R, Q, a1, P1, y) -&gt; KalmanFilterResultScalar</code></pre><p>Scalar version of full Kalman filter for univariate state-space models. Handles missing observations marked as NaN.</p><p>For <code>n</code> observations, returns <code>n</code> time points:</p><ul><li><code>at[t]</code> = E[αₜ | y₁:ₜ₋₁] (predicted state)</li><li><code>att[t]</code> = E[αₜ | y₁:ₜ] (filtered state)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/filter_ad.jl#L719-L728">source</a></section></details></article><h2 id="Kalman-Smoother"><a class="docs-heading-anchor" href="#Kalman-Smoother">Kalman Smoother</a><a id="Kalman-Smoother-1"></a><a class="docs-heading-anchor-permalink" href="#Kalman-Smoother" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Filthy.kalman_smoother"><a class="docstring-binding" href="#Filthy.kalman_smoother"><code>Filthy.kalman_smoother</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kalman_smoother(Z, T, at, Pt, vt, Ft; compute_crosscov=false, missing_mask=nothing, Ptt=nothing)</code></pre><p>AD-compatible RTS smoother. Takes filter outputs and returns smoothed states.</p><p><strong>Arguments</strong></p><ul><li><code>Z</code>: Observation matrix (p × m)</li><li><code>T</code>: Transition matrix (m × m)</li><li><code>at</code>: Predicted states (m × n), where at[:, t] = E[αₜ | y₁:ₜ₋₁]</li><li><code>Pt</code>: Predicted covariances (m × m × n)</li><li><code>vt</code>: Innovations (p × n), where vt[:, t] = yₜ - Z * at[:, t]</li><li><code>Ft</code>: Innovation covariances (p × p × n)</li><li><code>compute_crosscov</code>: If true, compute lag-one covariances P_{t+1,t|n} (default: false)</li><li><code>missing_mask</code>: Optional BitVector indicating missing observations (length n). If not provided, inferred from NaN values in vt.</li><li><code>Ptt</code>: Optional filtered covariances (m × m × n). Required for cross-cov with missing data. If not provided and compute_crosscov=true, computed from predicted covariances.</li></ul><p><strong>Returns</strong></p><p>Named tuple with:</p><ul><li><code>alpha</code>: Smoothed states (m × n), where alpha[:, t] = E[αₜ | y₁:ₙ]</li><li><code>V</code>: Smoothed covariances (m × m × n)</li><li><code>P_crosslag</code>: Cross-lag covariances P<em>{t+1,t|n} (m × m × (n-1)), only if compute</em>crosscov=true</li></ul><p><strong>Missing Data Handling</strong></p><p>When an observation is missing (indicated by <code>missing_mask[t] == true</code> or NaN in <code>vt[:, t]</code>), the smoother uses a simplified recursion that skips the measurement update:     r<em>{t-1} = T&#39; * r</em>t     N<em>{t-1} = T&#39; * N</em>t * T This is consistent with treating missing observations as having infinite variance.</p><p><strong>Cross-lag covariance formula</strong></p><p>Using Shumway &amp; Stoffer (2017), the lag-one covariance smoother gives:     J<em>t = P</em>{t|t} * T&#39; * inv(P<em>{t+1|t})     P</em>{t+1,t|n} = V<em>{t+1} * J</em>t&#39; where P_{t|t} is the filtered (updated) covariance.</p><p>For missing observations at time t, P<em>{t|t} = P</em>{t|t-1} (no update).</p><p><strong>Notes</strong></p><p>This follows Durbin &amp; Koopman (2012), Chapter 4, equations (4.32)-(4.44). Uses predicted states (at = a_{t|t-1}) not filtered states for the recursion. This is used by the EM algorithm which requires E[αₜ αₜ₋₁&#39; | y₁:ₙ] for M-step updates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/smoother_ad.jl#L9-L52">source</a></section><section><div><pre><code class="language-julia hljs">kalman_smoother(result::KalmanFilterResult, Z, T; compute_crosscov=false)</code></pre><p>Run RTS smoother using filter result. Convenience method.</p><p>Uses <code>missing_mask</code> from the filter result for proper handling of missing observations.</p><p><strong>Returns</strong></p><p>Named tuple with:</p><ul><li><code>alpha</code>: Smoothed states (m × n)</li><li><code>V</code>: Smoothed covariances (m × m × n)</li><li><code>P_crosslag</code>: Cross-lag covariances (only if compute_crosscov=true)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/smoother_ad.jl#L196-L208">source</a></section><section><div><pre><code class="language-julia hljs">kalman_smoother(p::KFParms, y, a1, P1; compute_crosscov=false) -&gt; NamedTuple</code></pre><p>High-level Kalman smoother that runs filter and smoother in one call.</p><p><strong>Arguments</strong></p><ul><li><code>p::KFParms</code>: State-space model parameters (Z, H, T, R, Q)</li><li><code>y</code>: Observations (p × n matrix)</li><li><code>a1</code>: Initial state mean (m-vector)</li><li><code>P1</code>: Initial state covariance (m × m matrix)</li><li><code>compute_crosscov</code>: If true, compute lag-one covariances (default: false)</li></ul><p><strong>Returns</strong></p><p>Named tuple with:</p><ul><li><code>α</code>: Smoothed states (m × n), where α[:, t] = E[αₜ | y₁:ₙ]</li><li><code>V</code>: Smoothed state covariances (m × m × n)</li><li><code>P_crosslag</code>: Cross-lag covariances (only if compute_crosscov=true)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">p = KFParms(Z, H, T, R, Q)
result = kalman_smoother(p, y, a1, P1)
smoothed_states = result.α</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/smoother_ad.jl#L217-L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.kalman_smoother_scalar"><a class="docstring-binding" href="#Filthy.kalman_smoother_scalar"><code>Filthy.kalman_smoother_scalar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kalman_smoother_scalar(Z, T, at, Pt, vt, Ft; missing_mask=nothing)</code></pre><p>Scalar version of RTS smoother for univariate state-space models.</p><p>Handles missing observations (NaN in vt or indicated by missing_mask).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/smoother_ad.jl#L297-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.kalman_filter_and_smooth"><a class="docstring-binding" href="#Filthy.kalman_filter_and_smooth"><code>Filthy.kalman_filter_and_smooth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kalman_filter_and_smooth(p::KFParms, y, a1, P1)</code></pre><p>Combined filter and smoother for state-space models.</p><p>Returns filtered states, smoothed states, and log-likelihood. AD-compatible.</p><p><strong>Arguments</strong></p><ul><li><code>p::KFParms</code>: State-space model parameters (Z, H, T, R, Q)</li><li><code>y</code>: Observations (p × n matrix)</li><li><code>a1</code>: Initial state mean (m-vector)</li><li><code>P1</code>: Initial state covariance (m × m matrix)</li></ul><p><strong>Returns</strong></p><p>Named tuple with:</p><ul><li><code>loglik</code>: Log-likelihood</li><li><code>a_filtered</code>: Filtered states (m × n) - same as att from filter result</li><li><code>P_filtered</code>: Filtered covariances (m × m × n) - same as Ptt from filter result</li><li><code>alpha_smooth</code>: Smoothed states (m × n)</li><li><code>V_smooth</code>: Smoothed covariances (m × m × n)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/smoother_ad.jl#L262-L283">source</a></section></details></article><h2 id="Prediction-and-Forecasting"><a class="docs-heading-anchor" href="#Prediction-and-Forecasting">Prediction and Forecasting</a><a id="Prediction-and-Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction-and-Forecasting" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Filthy.predict"><a class="docstring-binding" href="#Filthy.predict"><code>Filthy.predict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">predict(spec::SSMSpec, θ::NamedTuple, y::AbstractMatrix; use_static=true) -&gt; NamedTuple</code></pre><p>Compute in-sample one-step-ahead predictions for a state-space model.</p><p>For <code>n</code> observations, returns:</p><ul><li><code>yhat</code>: One-step-ahead predictions ŷₜ|ₜ₋₁ = Z * aₜ (obs_dim × n)</li><li><code>a</code>: States (state_dim × (n+1)), where a[:, t] = E[αₜ | y₁:ₜ₋₁]</li><li><code>P</code>: State covariances (state<em>dim × state</em>dim × (n+1))</li><li><code>v</code>: Innovations vₜ = yₜ - ŷₜ|ₜ₋₁ (obs_dim × n)</li><li><code>F</code>: Innovation covariances (obs<em>dim × obs</em>dim × n)</li><li><code>loglik</code>: Log-likelihood</li></ul><p>Note: <code>a[:, 1]</code> is the initial state, <code>a[:, n+1]</code> is the forecast state.</p><p><strong>Arguments</strong></p><ul><li><code>use_static::Bool=true</code>: Use StaticArrays for small matrices (dimensions ≤ 13)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">spec = local_level()
θ = (σ_obs = 1.0, σ_level = 0.5)
y = randn(1, 100)

pred = predict(spec, θ, y)
plot(vec(y), label=&quot;observed&quot;)
plot!(vec(pred.yhat), label=&quot;predicted&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/predict.jl#L91-L119">source</a></section><section><div><pre><code class="language-julia hljs">predict(p::KFParms, y, a1, P1) -&gt; NamedTuple</code></pre><p>Low-level prediction using KFParms directly.</p><p>Returns predicted states (at = a_{t|t-1}) and related quantities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/predict.jl#L125-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.forecast"><a class="docstring-binding" href="#Filthy.forecast"><code>Filthy.forecast</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">forecast(spec::SSMSpec, θ::NamedTuple, y::AbstractMatrix, h::Int; use_static=true) -&gt; NamedTuple</code></pre><p>Forecast h steps ahead beyond the observed data.</p><p>Returns a NamedTuple with:</p><ul><li><code>yhat</code>: Forecasted observations (obs_dim × h)</li><li><code>a</code>: Forecasted states (state_dim × h)</li><li><code>P</code>: Forecasted state covariances (state<em>dim × state</em>dim × h)</li><li><code>F</code>: Forecasted observation covariances (obs<em>dim × obs</em>dim × h)</li></ul><p>The forecast starts from <code>a[:, n+1]</code> = E[αₙ₊₁ | y₁:ₙ] from the filter.</p><p><strong>Arguments</strong></p><ul><li><code>use_static::Bool=true</code>: Use StaticArrays for small matrices (dimensions ≤ 13)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">spec = local_level()
θ = (σ_obs = 1.0, σ_level = 0.5)
y = randn(1, 100)

fc = forecast(spec, θ, y, 12)  # 12-step ahead forecast
println(&quot;Forecast: &quot;, fc.yhat)
println(&quot;Forecast std: &quot;, sqrt.(fc.F[1,1,:]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/predict.jl#L160-L186">source</a></section><section><div><pre><code class="language-julia hljs">forecast(p::KFParms, y, a1, P1, h) -&gt; NamedTuple</code></pre><p>Low-level forecasting using KFParms directly.</p><p>Starts from the last filtered state and propagates forward h steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/predict.jl#L192-L198">source</a></section><section><div><pre><code class="language-julia hljs">forecast(model::StateSpaceModel, h::Int)</code></pre><p>Forecast h steps ahead from fitted model.</p><p>Uses the filtered state at the last observation and iterates forward.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Fitted StateSpaceModel</li><li><code>h</code>: Forecast horizon</li></ul><p><strong>Returns</strong></p><p>NamedTuple with:</p><ul><li><code>yhat</code>: Forecasted observations (p × h)</li><li><code>a</code>: Forecasted states (m × h)</li><li><code>P</code>: Forecasted state covariances (m × m × h)</li><li><code>F</code>: Forecasted observation covariances (p × p × h)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = StateSpaceModel(local_level(), 100)
fit!(MLE(), model, y)
fc = forecast(model, 10)
fc.yhat  # 1 × 10 forecasts</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/inplace.jl#L2703-L2728">source</a></section><section><div><pre><code class="language-julia hljs">forecast(model::DynamicFactorModel, h::Int)</code></pre><p>Compute h-step ahead forecasts from a fitted DFM.</p><p>Uses the filtered state at the last observation (αₙ|ₙ, Pₙ|ₙ) and iterates the state equation forward:     E[αₙ₊ₕ|Y₁:ₙ] = Tʰ αₙ|ₙ     Var[αₙ₊ₕ|Y₁:ₙ] = Tʰ Pₙ|ₙ (T&#39;)ʰ + Σⱼ₌₀ʰ⁻¹ Tʲ RQR&#39; (T&#39;)ʲ</p><p><strong>Arguments</strong></p><ul><li><code>model::DynamicFactorModel</code> - Fitted DFM model</li><li><code>h::Int</code> - Forecast horizon</li></ul><p><strong>Returns</strong></p><ul><li><code>DynamicFactorModelForecast</code> with forecasted states and observations</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = DynamicFactorModel(100, 6, 200; factor_lags=3)
fit!(EM(), model, y)
fc = forecast(model, 4)
ci = forecast_interval(fc, 0.05)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/inplace.jl#L3764-L3788">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.forecast_paths"><a class="docstring-binding" href="#Filthy.forecast_paths"><code>Filthy.forecast_paths</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">forecast_paths(spec::SSMSpec, θ::NamedTuple, y::AbstractMatrix, h::Int, n_paths::Int; use_static=true) -&gt; Array</code></pre><p>Simulate n_paths forecast trajectories of length h.</p><p>Returns an array of size (obs<em>dim × h × n</em>paths).</p><p>Useful for fan charts and prediction intervals.</p><p><strong>Arguments</strong></p><ul><li><code>use_static::Bool=true</code>: Use StaticArrays for small matrices (dimensions ≤ 13)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">paths = forecast_paths(spec, θ, y, 12, 1000)
quantiles = [quantile(paths[1, j, :], [0.1, 0.5, 0.9]) for j in 1:12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/predict.jl#L237-L254">source</a></section></details></article><h2 id="Missing-Data-Utilities"><a class="docs-heading-anchor" href="#Missing-Data-Utilities">Missing Data Utilities</a><a id="Missing-Data-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-Data-Utilities" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Filthy.missing_to_nan"><a class="docstring-binding" href="#Filthy.missing_to_nan"><code>Filthy.missing_to_nan</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">missing_to_nan(y::AbstractArray)</code></pre><p>Convert <code>missing</code> values to <code>NaN</code>. Returns a Float64 array.</p><p>Use this if your data contains <code>missing</code> values:</p><pre><code class="language-julia hljs">y_clean = missing_to_nan(y_with_missing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/predict.jl#L33-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.nan_to_missing"><a class="docstring-binding" href="#Filthy.nan_to_missing"><code>Filthy.nan_to_missing</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nan_to_missing(y::AbstractArray)</code></pre><p>Convert <code>NaN</code> values to <code>missing</code>. Returns a Union{Float64, Missing} array.</p><p>Use this if you prefer working with <code>missing</code>:</p><pre><code class="language-julia hljs">y_missing = nan_to_missing(y_with_nan)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/predict.jl#L53-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.count_missing"><a class="docstring-binding" href="#Filthy.count_missing"><code>Filthy.count_missing</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">count_missing(y::AbstractMatrix) -&gt; Int</code></pre><p>Count number of time periods with at least one missing observation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/predict.jl#L71-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.ismissing_obs"><a class="docstring-binding" href="#Filthy.ismissing_obs"><code>Filthy.ismissing_obs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ismissing_obs(y_t::AbstractVector) -&gt; Bool</code></pre><p>Check if observation vector contains any missing values (NaN).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/predict.jl#L19-L23">source</a></section><section><div><pre><code class="language-julia hljs">ismissing_obs(y_t::Real) -&gt; Bool</code></pre><p>Check if scalar observation is missing (NaN).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/predict.jl#L26-L30">source</a></section></details></article><h2 id="StaticArrays-Utilities"><a class="docs-heading-anchor" href="#StaticArrays-Utilities">StaticArrays Utilities</a><a id="StaticArrays-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#StaticArrays-Utilities" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Filthy.STATIC_THRESHOLD"><a class="docstring-binding" href="#Filthy.STATIC_THRESHOLD"><code>Filthy.STATIC_THRESHOLD</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Maximum dimension for automatic conversion to StaticArrays. Matrices with max(rows, cols) ≤ STATIC_THRESHOLD are converted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/types.jl#L41-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Filthy.to_static_if_small"><a class="docstring-binding" href="#Filthy.to_static_if_small"><code>Filthy.to_static_if_small</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_static_if_small(x)</code></pre><p>Convert array to StaticArray if dimensions are small enough (≤ STATIC_THRESHOLD). Returns the input unchanged if dimensions exceed threshold or if already a StaticArray.</p><p>This enables automatic performance optimization for small state-space models by using stack-allocated arrays that the compiler can unroll.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Filthy.jl/blob/8791c67128e878be38444e198304e9edc0e1f7a0/src/types.jl#L47-L55">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/visualization.html">« Visualization</a><a class="docs-footer-nextpage" href="dsl.html">DSL &amp; Templates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 25 December 2025 11:12">Thursday 25 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
