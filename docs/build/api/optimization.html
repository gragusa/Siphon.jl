<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Estimation &amp; Bayesian · Siphon</title><meta name="title" content="Estimation &amp; Bayesian · Siphon"/><meta property="og:title" content="Estimation &amp; Bayesian · Siphon"/><meta property="twitter:title" content="Estimation &amp; Bayesian · Siphon"/><meta name="description" content="Documentation for Siphon."/><meta property="og:description" content="Documentation for Siphon."/><meta property="twitter:description" content="Documentation for Siphon."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Siphon</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/getting_started.html">Getting Started</a></li><li><a class="tocitem" href="../tutorials/custom_models.html">Custom Models</a></li><li><a class="tocitem" href="../tutorials/dynamic_factor.html">Dynamic Factor Models</a></li><li><a class="tocitem" href="../tutorials/arma_models.html">ARMA Models</a></li><li><a class="tocitem" href="../tutorials/estimation_methods.html">Estimation Methods</a></li><li><a class="tocitem" href="../tutorials/transformations.html">Parameter Transformations</a></li><li><a class="tocitem" href="../tutorials/initial_state.html">Initial State Conventions</a></li><li><a class="tocitem" href="../tutorials/visualization.html">Visualization</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="core.html">Core Functions</a></li><li><a class="tocitem" href="dsl.html">DSL &amp; Templates</a></li><li><a class="tocitem" href="matrix_helpers.html">Matrix Helpers</a></li><li class="is-active"><a class="tocitem" href="optimization.html">Estimation &amp; Bayesian</a><ul class="internal"><li><a class="tocitem" href="#High-Level-Unified-API"><span>High-Level Unified API</span></a></li><li><a class="tocitem" href="#StateSpaceModel-Constructors"><span>StateSpaceModel Constructors</span></a></li><li><a class="tocitem" href="#Estimation-Methods"><span>Estimation Methods</span></a></li><li><a class="tocitem" href="#Unified-Filter/Smoother-Methods"><span>Unified Filter/Smoother Methods</span></a></li><li><a class="tocitem" href="#Model-Accessors"><span>Model Accessors</span></a></li><li><a class="tocitem" href="#Direct-Optimization"><span>Direct Optimization</span></a></li><li><a class="tocitem" href="#Profile-EM-for-DNS-Models"><span>Profile EM for DNS Models</span></a></li><li><a class="tocitem" href="#Initial-State-Conventions-and-MARSS-Compatibility"><span>Initial State Conventions and MARSS Compatibility</span></a></li><li><a class="tocitem" href="#Parameter-Transformations"><span>Parameter Transformations</span></a></li><li><a class="tocitem" href="#Log-Density-Interface"><span>Log-Density Interface</span></a></li><li><a class="tocitem" href="#Prior-Distributions"><span>Prior Distributions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="optimization.html">Estimation &amp; Bayesian</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="optimization.html">Estimation &amp; Bayesian</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gragusa/Siphon.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gragusa/Siphon.jl/blob/master/docs/src/api/optimization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Estimation-and-Bayesian"><a class="docs-heading-anchor" href="#Estimation-and-Bayesian">Estimation &amp; Bayesian</a><a id="Estimation-and-Bayesian-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-and-Bayesian" title="Permalink"></a></h1><p>This page documents functions for parameter estimation and Bayesian inference.</p><h2 id="High-Level-Unified-API"><a class="docs-heading-anchor" href="#High-Level-Unified-API">High-Level Unified API</a><a id="High-Level-Unified-API-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-Unified-API" title="Permalink"></a></h2><p>Siphon.jl provides a unified API centered around <code>StateSpaceModel</code>. There are two ways to create a model:</p><h3 id="Option-1:-Create-Model-with-Known-Parameters"><a class="docs-heading-anchor" href="#Option-1:-Create-Model-with-Known-Parameters">Option 1: Create Model with Known Parameters</a><a id="Option-1:-Create-Model-with-Known-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Option-1:-Create-Model-with-Known-Parameters" title="Permalink"></a></h3><p>If you already have parameter values (from prior knowledge, simulation, or external estimation):</p><pre><code class="language-julia hljs">using Siphon

spec = local_level()
θ = (var_obs=15099.0, var_level=1469.0)

# Create model with known parameters
model = StateSpaceModel(spec, θ, n_obs)

# Run filter and smoother
ll = kalman_filter!(model, y)
kalman_smoother!(model)

# Access results
loglikelihood(model)        # Log-likelihood
filtered_states(model)      # E[αₜ|y₁:ₜ]
smoothed_states(model)      # E[αₜ|y₁:ₙ]
parameters(model)           # Parameter NamedTuple</code></pre><h3 id="Option-2:-Estimate-Parameters"><a class="docs-heading-anchor" href="#Option-2:-Estimate-Parameters">Option 2: Estimate Parameters</a><a id="Option-2:-Estimate-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Option-2:-Estimate-Parameters" title="Permalink"></a></h3><p>If you want to estimate parameters from data:</p><pre><code class="language-julia hljs">using Siphon

spec = local_level()
model = StateSpaceModel(spec, n_obs)

# Maximum likelihood estimation
fit!(MLE(), model, y)

# Or EM algorithm estimation
fit!(EM(), model, y; maxiter=200, tol=1e-6, verbose=true)

# Access results
loglikelihood(model)        # Log-likelihood at optimum
parameters(model)           # Fitted parameters as NamedTuple
isconverged(model)          # Whether estimation converged
niterations(model)          # Number of iterations (EM only)

# Access system matrices at fitted parameters
mats = system_matrices(model)  # All matrices as NamedTuple
mats.Z  # Observation matrix
mats.H  # Observation covariance
mats.T  # Transition matrix
mats.R  # Selection matrix
mats.Q  # State covariance

# Or access individually
obs_matrix(model)        # Z
obs_cov(model)           # H
transition_matrix(model) # T
selection_matrix(model)  # R
state_cov(model)         # Q

# Access filter/smoother results
filtered_states(model)     # E[αₜ|y₁:ₜ]
smoothed_states(model)     # E[αₜ|y₁:ₙ] (computed on demand)
prediction_errors(model)   # yₜ - E[yₜ|y₁:ₜ₋₁]</code></pre><h2 id="StateSpaceModel-Constructors"><a class="docs-heading-anchor" href="#StateSpaceModel-Constructors">StateSpaceModel Constructors</a><a id="StateSpaceModel-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceModel-Constructors" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Siphon.StateSpaceModel"><a class="docstring-binding" href="#Siphon.StateSpaceModel"><code>Siphon.StateSpaceModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StateSpaceModel{T}</code></pre><p>Mutable state-space model container wrapping an SSMSpec.</p><p>Supports both MLE and EM estimation with automatic backend selection for EM.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs"># Create from SSMSpec
spec = local_level(var_obs=:free, var_level=:free)
model = StateSpaceModel(spec, 200)

# Fit with MLE (pure Kalman filter, AD-compatible)
fit!(MLE(), model, y)

# Or fit with EM (auto-selects backend based on dimensions)
fit!(EM(), model, y; maxiter=500, verbose=true)

# Access results
params = parameters(model)         # NamedTuple
f = filtered_states(model)         # m × n
s = smoothed_states(model)         # computed on-demand

# Forecast
fc = forecast(model, 10)</code></pre><p><strong>Backend Selection for EM</strong></p><ul><li>If max(n<em>states, n</em>obs) &gt; 13: uses in-place KalmanWorkspace (zero allocations)</li><li>Otherwise: uses pure StaticArrays implementation</li></ul><p><strong>Fields (internal)</strong></p><p>See source for field documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2281-L2315">source</a></section></details></article><h2 id="Estimation-Methods"><a class="docs-heading-anchor" href="#Estimation-Methods">Estimation Methods</a><a id="Estimation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-Methods" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Siphon.MLE"><a class="docstring-binding" href="#Siphon.MLE"><code>Siphon.MLE</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MLE</code></pre><p>Estimation method type for direct Maximum Likelihood Estimation. Used with <code>fit!(MLE(), model, data; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2242-L2247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.EM"><a class="docstring-binding" href="#Siphon.EM"><code>Siphon.EM</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EM</code></pre><p>Estimation method type for EM (Expectation-Maximization) algorithm. Used with <code>fit!(EM(), model, data; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2234-L2239">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.fit!"><a class="docstring-binding" href="#Siphon.fit!"><code>Siphon.fit!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit!(::MLE, model::StateSpaceModel, y::AbstractMatrix; kwargs...)</code></pre><p>Fit state-space model using Maximum Likelihood Estimation.</p><p>Uses the pure AD-compatible Kalman filter via Optimization.jl. Automatically uses StaticArrays for small models (dims ≤ 13).</p><p><strong>Arguments</strong></p><ul><li><code>MLE()</code>: Estimation method selector</li><li><code>model</code>: StateSpaceModel to fit (mutated in-place)</li><li><code>y</code>: Observations (p × n matrix), missing values as NaN</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method</code>: Optimization algorithm (default: LBFGS from Optim.jl)</li><li><code>verbose</code>: Print optimization progress (default: false)</li><li>Additional kwargs passed to optimize_ssm</li></ul><p><strong>Returns</strong></p><p>The fitted <code>model</code> (same object, mutated)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">spec = local_level(var_obs=:free, var_level=:free)
model = StateSpaceModel(spec, 100)
fit!(MLE(), model, randn(1, 100))
parameters(model)  # (var_obs=..., var_level=...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2938-L2966">source</a></section><section><div><pre><code class="language-julia hljs">fit!(::EM, model::StateSpaceModel, y::AbstractMatrix; kwargs...)</code></pre><p>Fit state-space model using EM algorithm.</p><p>Automatically selects backend based on dimensions:</p><ul><li>If max(n<em>states, n</em>obs) &gt; 13: Use in-place KalmanWorkspace (zero allocations)</li><li>Otherwise: Use pure implementation</li></ul><p><strong>Arguments</strong></p><ul><li><code>EM()</code>: Estimation method selector</li><li><code>model</code>: StateSpaceModel to fit (mutated in-place)</li><li><code>y</code>: Observations (p × n matrix), missing values as NaN</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>maxiter::Int=500</code>: Maximum EM iterations</li><li><code>tol::Real=1e-6</code>: Convergence tolerance (relative change in log-likelihood)</li><li><code>verbose::Bool=false</code>: Print progress</li></ul><p><strong>Returns</strong></p><p>The fitted <code>model</code> (same object, mutated)</p><p><strong>Note</strong></p><p>EM estimation requires that free parameters are marked in the SSMSpec. For general state-space models, EM typically updates H and Q (covariances).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">spec = local_level(var_obs=:free, var_level=:free)
model = StateSpaceModel(spec, 100)
fit!(EM(), model, randn(1, 100); maxiter=200, verbose=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L3011-L3043">source</a></section><section><div><pre><code class="language-julia hljs">fit!(::EM, model::DynamicFactorModel, y::AbstractMatrix;
     maxiter::Int=500, tol::Real=1e-6, verbose::Bool=false)</code></pre><p>Fit a dynamic factor model using the EM algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>EM()</code>: Estimation method selector</li><li><code>model</code>: DynamicFactorModel to fit (mutated in-place)</li><li><code>y</code>: Observations (N × n matrix), missing values as NaN</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>maxiter</code>: Maximum EM iterations (default: 500)</li><li><code>tol</code>: Convergence tolerance for log-likelihood (default: 1e-6)</li><li><code>verbose</code>: Print progress (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>The fitted <code>model</code> (same object, mutated)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = DynamicFactorModel(100, 6, 200; factor_lags=3)
fit!(EM(), model, y; verbose=true)
f = factors(model)  # k × n smoothed factors</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L4797-L4822">source</a></section></details></article><h2 id="Unified-Filter/Smoother-Methods"><a class="docs-heading-anchor" href="#Unified-Filter/Smoother-Methods">Unified Filter/Smoother Methods</a><a id="Unified-Filter/Smoother-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Unified-Filter/Smoother-Methods" title="Permalink"></a></h2><p>These methods work directly on <code>StateSpaceModel</code> objects:</p><pre><code class="language-julia hljs"># Log-likelihood (doesn&#39;t modify model state)
ll = kalman_loglik(model, y)

# Filter (stores results in model)
ll = kalman_filter!(model, y)

# Smoother (uses stored filter results)
kalman_smoother!(model)</code></pre><article><details class="docstring" open="true"><summary id="Siphon.kalman_loglik-Tuple{StateSpaceModel, AbstractMatrix}"><a class="docstring-binding" href="#Siphon.kalman_loglik-Tuple{StateSpaceModel, AbstractMatrix}"><code>Siphon.kalman_loglik</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kalman_loglik(model::StateSpaceModel, y::AbstractMatrix) -&gt; Real</code></pre><p>Compute log-likelihood using the model&#39;s current parameters.</p><p>This is a convenience method that builds system matrices from stored parameters and computes the log-likelihood without modifying the model&#39;s internal state.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: StateSpaceModel with fitted parameters</li><li><code>y</code>: Observations (p × n matrix), missing values as NaN</li></ul><p><strong>Returns</strong></p><p>Log-likelihood value (Real)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">spec = local_level()
θ = (var_obs=100.0, var_level=50.0)
model = StateSpaceModel(spec, θ, 100)

y = randn(1, 100)
ll = kalman_loglik(model, y)</code></pre><p>See also: <a href="optimization.html#Siphon.kalman_filter!-Tuple{StateSpaceModel, AbstractMatrix}"><code>kalman_filter!</code></a>, <a href="optimization.html#Siphon.loglikelihood"><code>loglikelihood</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2694-L2720">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.kalman_filter!-Tuple{StateSpaceModel, AbstractMatrix}"><a class="docstring-binding" href="#Siphon.kalman_filter!-Tuple{StateSpaceModel, AbstractMatrix}"><code>Siphon.kalman_filter!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kalman_filter!(model::StateSpaceModel, y::AbstractMatrix) -&gt; Real</code></pre><p>Run Kalman filter and store results in model. Returns log-likelihood.</p><p>After calling this function:</p><ul><li><code>filtered_states(model)</code> returns E[αₜ|y₁:ₜ]</li><li><code>predicted_states(model)</code> returns E[αₜ|y₁:ₜ₋₁]</li><li><code>loglikelihood(model)</code> returns the log-likelihood</li><li>Model is ready for <code>kalman_smoother!(model)</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>model</code>: StateSpaceModel with fitted parameters (mutated in-place)</li><li><code>y</code>: Observations (p × n matrix), missing values as NaN</li></ul><p><strong>Returns</strong></p><p>Log-likelihood value (Real)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">spec = local_level()
θ = (var_obs=100.0, var_level=50.0)
model = StateSpaceModel(spec, θ, 100)

y = randn(1, 100)
ll = kalman_filter!(model, y)
filtered_states(model)  # Access filtered states</code></pre><p>See also: <a href="optimization.html#Siphon.kalman_smoother!-Tuple{StateSpaceModel}"><code>kalman_smoother!</code></a>, <a href="core.html#Siphon.kalman_loglik"><code>kalman_loglik</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2740-L2770">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.kalman_smoother!-Tuple{StateSpaceModel}"><a class="docstring-binding" href="#Siphon.kalman_smoother!-Tuple{StateSpaceModel}"><code>Siphon.kalman_smoother!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kalman_smoother!(model::StateSpaceModel) -&gt; Nothing</code></pre><p>Run Kalman smoother using stored filter results.</p><p>Requires <code>kalman_filter!(model, y)</code> to have been called first. After calling this function, <code>smoothed_states(model)</code> returns E[αₜ|y₁:ₙ].</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: StateSpaceModel with valid filter results (mutated in-place)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">spec = local_level()
θ = (var_obs=100.0, var_level=50.0)
model = StateSpaceModel(spec, θ, 100)

y = randn(1, 100)
kalman_filter!(model, y)
kalman_smoother!(model)
smoothed_states(model)  # Access smoothed states</code></pre><p>See also: <a href="optimization.html#Siphon.kalman_filter!-Tuple{StateSpaceModel, AbstractMatrix}"><code>kalman_filter!</code></a>, <a href="optimization.html#Siphon.smoothed_states"><code>smoothed_states</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2800-L2824">source</a></section></details></article><h2 id="Model-Accessors"><a class="docs-heading-anchor" href="#Model-Accessors">Model Accessors</a><a id="Model-Accessors-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Accessors" title="Permalink"></a></h2><p>After fitting a <code>StateSpaceModel</code>, use these functions to access results:</p><h3 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Siphon.parameters"><a class="docstring-binding" href="#Siphon.parameters"><code>Siphon.parameters</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">parameters(r::KalmanFilterResult) -&gt; KFParms</code></pre><p>Return the model parameters (Z, H, T, R, Q).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L215-L219">source</a></section><section><div><p>Return fitted parameters as NamedTuple. Throws if not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2576">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.loglikelihood"><a class="docstring-binding" href="#Siphon.loglikelihood"><code>Siphon.loglikelihood</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">loglikelihood(r::KalmanFilterResult) -&gt; Real</code></pre><p>Return log-likelihood of non-missing observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L307-L311">source</a></section><section><div><pre><code class="language-julia hljs">loglikelihood(ws::KalmanWorkspace) -&gt; Real</code></pre><p>Return log-likelihood of non-missing observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L334-L338">source</a></section><section><div><p>Return log-likelihood at fitted parameters. Throws if not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2564">source</a></section><section><div><pre><code class="language-julia hljs">loglikelihood(model::DynamicFactorModel) -&gt; T</code></pre><p>Return final log-likelihood. Throws error if model not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L4650-L4654">source</a></section></details></article><h3 id="System-Matrices"><a class="docs-heading-anchor" href="#System-Matrices">System Matrices</a><a id="System-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#System-Matrices" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Siphon.system_matrices"><a class="docstring-binding" href="#Siphon.system_matrices"><code>Siphon.system_matrices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">system_matrices(model::StateSpaceModel)</code></pre><p>Return all system matrices as a NamedTuple (Z, H, T, R, Q) at fitted parameters.</p><p>This is more efficient than calling individual accessors when multiple matrices are needed.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mats = system_matrices(model)
mats.Z  # observation matrix
mats.H  # observation covariance
mats.T  # transition matrix
mats.R  # selection matrix
mats.Q  # state covariance</code></pre><p>Throws if model is not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2908-L2926">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.obs_matrix"><a class="docstring-binding" href="#Siphon.obs_matrix"><code>Siphon.obs_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">obs_matrix(r::KalmanFilterResult)</code></pre><p>Return observation matrix Z (p × m).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L222-L226">source</a></section><section><div><pre><code class="language-julia hljs">obs_matrix(model::StateSpaceModel)</code></pre><p>Return observation matrix Z (p × m) at fitted parameters.</p><p>Throws if model is not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2838-L2844">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.obs_cov"><a class="docstring-binding" href="#Siphon.obs_cov"><code>Siphon.obs_cov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">obs_cov(r::KalmanFilterResult)</code></pre><p>Return observation noise covariance H (p × p).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L229-L233">source</a></section><section><div><pre><code class="language-julia hljs">obs_cov(model::StateSpaceModel)</code></pre><p>Return observation noise covariance H (p × p) at fitted parameters.</p><p>Throws if model is not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2852-L2858">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.transition_matrix"><a class="docstring-binding" href="#Siphon.transition_matrix"><code>Siphon.transition_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transition_matrix(r::KalmanFilterResult)</code></pre><p>Return state transition matrix T (m × m).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L236-L240">source</a></section><section><div><pre><code class="language-julia hljs">transition_matrix(model::StateSpaceModel)</code></pre><p>Return state transition matrix T (m × m) at fitted parameters.</p><p>Throws if model is not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2866-L2872">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.selection_matrix"><a class="docstring-binding" href="#Siphon.selection_matrix"><code>Siphon.selection_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">selection_matrix(r::KalmanFilterResult)</code></pre><p>Return state noise selection matrix R (m × r).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L243-L247">source</a></section><section><div><pre><code class="language-julia hljs">selection_matrix(model::StateSpaceModel)</code></pre><p>Return state noise selection matrix R (m × r) at fitted parameters.</p><p>Throws if model is not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2880-L2886">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.state_cov"><a class="docstring-binding" href="#Siphon.state_cov"><code>Siphon.state_cov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_cov(r::KalmanFilterResult)</code></pre><p>Return state noise covariance Q (r × r).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L250-L254">source</a></section><section><div><pre><code class="language-julia hljs">state_cov(model::StateSpaceModel)</code></pre><p>Return state noise covariance Q (r × r) at fitted parameters.</p><p>Throws if model is not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2894-L2900">source</a></section></details></article><h3 id="Filter-and-Smoother-Results"><a class="docs-heading-anchor" href="#Filter-and-Smoother-Results">Filter and Smoother Results</a><a id="Filter-and-Smoother-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-and-Smoother-Results" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Siphon.filtered_states"><a class="docstring-binding" href="#Siphon.filtered_states"><code>Siphon.filtered_states</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">filtered_states(r::KalmanFilterResult) -&gt; Matrix</code></pre><p>Return filtered state means E[αₜ | y₁:ₜ] for t = 1:n. (FKF: att)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L271-L275">source</a></section><section><div><pre><code class="language-julia hljs">filtered_states(ws::KalmanWorkspace) -&gt; Matrix</code></pre><p>Return filtered state means E[αₜ | y₁:ₜ] (m × n).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L282-L286">source</a></section><section><div><p>Return filtered states E[αₜ|y₁:ₜ] (m × n). Throws if not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2586">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.predicted_states"><a class="docstring-binding" href="#Siphon.predicted_states"><code>Siphon.predicted_states</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">predicted_states(r::KalmanFilterResult) -&gt; Matrix</code></pre><p>Return predicted state means E[αₜ | y₁:ₜ₋₁] for t = 1:n. (FKF: at)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L257-L261">source</a></section><section><div><pre><code class="language-julia hljs">predicted_states(ws::KalmanWorkspace) -&gt; Matrix</code></pre><p>Return predicted state means E[αₜ | y₁:ₜ₋₁] (m × n).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L268-L272">source</a></section><section><div><p>Return predicted states E[αₜ|y₁:ₜ₋₁] (m × n). Throws if not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2598">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.smoothed_states"><a class="docstring-binding" href="#Siphon.smoothed_states"><code>Siphon.smoothed_states</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">smoothed_states(w::SmootherWorkspace) -&gt; Matrix</code></pre><p>Return smoothed state means E[αₜ | y₁:ₙ] from workspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L382-L386">source</a></section><section><div><pre><code class="language-julia hljs">smoothed_states(ws::KalmanWorkspace) -&gt; Matrix</code></pre><p>Return smoothed state means E[αₜ | y₁:ₙ] (m × n). Must call <code>kalman_smoother!(ws)</code> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L296-L301">source</a></section><section><div><pre><code class="language-julia hljs">smoothed_states(model::StateSpaceModel)</code></pre><p>Return smoothed states E[αₜ|y₁:ₙ] (m × n).</p><p>Computes smoother on first call and caches the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2645-L2651">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.prediction_errors"><a class="docstring-binding" href="#Siphon.prediction_errors"><code>Siphon.prediction_errors</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prediction_errors(r::KalmanFilterResult) -&gt; Matrix</code></pre><p>Return prediction errors (innovations) vₜ = yₜ - E[yₜ | y₁:ₜ₋₁] for t = 1:n. (FKF: vt) NaN for missing observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/types.jl#L285-L290">source</a></section><section><div><pre><code class="language-julia hljs">prediction_errors(ws::KalmanWorkspace) -&gt; Matrix</code></pre><p>Return prediction errors (innovations) vₜ = yₜ - Z*aₜ (p × n). NaN for missing observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L312-L317">source</a></section><section><div><p>Return prediction errors / innovations yₜ - E[yₜ|y₁:ₜ₋₁] (p × n). Throws if not fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/inplace.jl#L2610">source</a></section></details></article><h2 id="Direct-Optimization"><a class="docs-heading-anchor" href="#Direct-Optimization">Direct Optimization</a><a id="Direct-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Optimization" title="Permalink"></a></h2><p>For more control, use <code>optimize_ssm</code> directly:</p><article><details class="docstring" open="true"><summary id="Siphon.DSL.optimize_ssm"><a class="docstring-binding" href="#Siphon.DSL.optimize_ssm"><code>Siphon.DSL.optimize_ssm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">optimize_ssm(spec, y; method=Optim.LBFGS(), kwargs...)</code></pre><p>Optimize state-space model parameters using Optimization.jl.</p><p>Works in unconstrained parameter space using automatic differentiation for gradient computation.</p><p><strong>Arguments</strong></p><ul><li><code>spec::SSMSpec</code>: Model specification</li><li><code>y::AbstractMatrix</code>: Observations (p × n matrix)</li><li><code>method</code>: Optimization algorithm (default: L-BFGS)</li><li><code>θ0</code>: Initial parameter values (constrained). Default: <code>initial_values(spec)</code></li><li><code>ad_backend</code>: AD backend for gradients (default: <code>Optimization.AutoForwardDiff()</code>)</li><li><code>use_static::Bool=true</code>: Use StaticArrays for small matrices (dimensions ≤ 13)</li><li><code>prob_kwargs</code>: NamedTuple of kwargs passed to <code>OptimizationProblem</code></li><li><code>kwargs...</code>: All other kwargs passed to <code>Optimization.solve</code></li></ul><p><strong>Common solve kwargs</strong></p><ul><li><code>maxiters</code>: Maximum iterations (default: 1000)</li><li><code>maxtime</code>: Maximum time in seconds</li><li><code>abstol</code>: Absolute tolerance</li><li><code>reltol</code>: Relative tolerance</li><li><code>callback</code>: Callback function <code>(state, loss) -&gt; Bool</code> (return true to stop)</li><li><code>progress</code>: Show progress bar (requires ProgressLogging.jl)</li><li><code>show_trace</code>: Show optimization trace (Optim.jl specific)</li></ul><p><strong>Returns</strong></p><p>Named tuple with:</p><ul><li><code>θ</code>: Optimal parameters (constrained space)</li><li><code>loglik</code>: Log-likelihood at optimum</li><li><code>result</code>: Full Optimization.jl result object</li><li><code>converged</code>: Whether optimization converged</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">spec = local_level()
y = randn(1, 100) .* 10 .+ 100

# Basic usage
result = optimize_ssm(spec, y)

println(&quot;Optimal parameters: &quot;, result.θ)
println(&quot;Log-likelihood: &quot;, result.loglik)

# With custom initial values
result2 = optimize_ssm(spec, y; θ0=(σ_obs=150.0, σ_level=50.0))

# Different optimizer with options
result3 = optimize_ssm(spec, y;
    method=Optim.Newton(),
    maxiters=500,
    show_trace=true
)

# With callback for monitoring
callback = (state, loss) -&gt; begin
    println(&quot;Iteration: loss = $loss&quot;)
    return false  # return true to stop
end
result4 = optimize_ssm(spec, y; callback=callback)

# Pass kwargs to OptimizationProblem (e.g., bounds in unconstrained space)
result5 = optimize_ssm(spec, y;
    prob_kwargs=(lb=fill(-10.0, n_params(spec)),
                 ub=fill(10.0, n_params(spec)))
)

# Disable StaticArrays (for debugging or if causing issues)
result6 = optimize_ssm(spec, y; use_static=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/optimization.jl#L16-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.DSL.optimize_ssm_with_stderr"><a class="docstring-binding" href="#Siphon.DSL.optimize_ssm_with_stderr"><code>Siphon.DSL.optimize_ssm_with_stderr</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">optimize_ssm_with_stderr(spec, y; use_static=true, kwargs...)</code></pre><p>Optimize SSM and compute standard errors using the Hessian.</p><p>Returns the same as <code>optimize_ssm</code> plus:</p><ul><li><code>stderr</code>: Standard errors of parameters (in constrained space, approximate)</li><li><code>hessian</code>: Hessian matrix at the optimum (in unconstrained space)</li></ul><p>Note: Standard errors are approximate when using parameter transformations. For accurate standard errors on constrained parameters, use the delta method or bootstrap.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/optimization.jl#L134-L146">source</a></section></details></article><h2 id="Profile-EM-for-DNS-Models"><a class="docs-heading-anchor" href="#Profile-EM-for-DNS-Models">Profile EM for DNS Models</a><a id="Profile-EM-for-DNS-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Profile-EM-for-DNS-Models" title="Permalink"></a></h2><p>For Dynamic Nelson-Siegel models with nonlinear λ parameter:</p><article><details class="docstring" open="true"><summary id="Siphon.DSL.profile_em_ssm"><a class="docstring-binding" href="#Siphon.DSL.profile_em_ssm"><code>Siphon.DSL.profile_em_ssm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">profile_em_ssm(spec::SSMSpec, y::AbstractMatrix; kwargs...) -&gt; ProfileEMResult</code></pre><p>Estimate a state-space model using profile EM: grid search over λ (or other MatrixExpr parameters) with EM for remaining parameters at each grid point.</p><p>This is particularly useful for DNS models where λ enters the Z matrix non-linearly and cannot be efficiently estimated via standard EM.</p><p><strong>Algorithm</strong></p><ol><li>Grid over λ values</li><li>For each λ: fix Z(λ), run EM to estimate T, H, Q</li><li>Return λ with highest profile log-likelihood</li></ol><p><strong>Arguments</strong></p><ul><li><code>spec::SSMSpec</code>: Model specification with MatrixExpr for Z (e.g., from <code>dns_model()</code>)</li><li><code>y::AbstractMatrix</code>: Observations (p × n)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>λ_grid</code>: Grid of λ values to search (default: 0.01:0.005:0.2)</li><li><code>λ_param::Symbol=:λ</code>: Name of the profiled parameter</li><li><code>verbose::Bool=false</code>: Print progress</li><li><code>maxiter::Int=500</code>: Max EM iterations per λ</li><li><code>tol_ll::Real=1e-6</code>: EM convergence tolerance</li><li><code>warm_start::Bool=true</code>: Use previous EM solution as starting point</li><li><code>update_initial_state::Bool=false</code>: If true, update initial state (a1, P1) at each EM iteration using smoothed state estimates (MARSS-style). Default: false.</li><li><code>tinitx::Int=0</code>: Initial state timing convention (MARSS-style):<ul><li><code>tinitx=0</code>: Initial state (a1, P1) is at t=0. P1 is computed as <code>T * V0 * T&#39; + R * Q * R&#39;</code>.</li><li><code>tinitx=1</code>: Initial state (a1, P1) is at t=1. P1 = V0 directly (no transformation).</li></ul></li><li><code>V0::Union{Real,AbstractMatrix}=100.0</code>: Initial state covariance. Can be a scalar (interpreted as <code>V0 * I</code>) or a matrix. Interpretation depends on <code>tinitx</code>.</li></ul><p><strong>Returns</strong></p><p><code>ProfileEMResult</code> with optimal parameters and profile likelihood</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">maturities = [3, 6, 12, 24, 60, 120]
spec = dns_model(maturities; T_structure=:full, Q_structure=:full)

# Profile EM estimation
result = profile_em_ssm(spec, yields; λ_grid=0.02:0.005:0.15, verbose=true)

println(&quot;Optimal λ: &quot;, result.λ_optimal)
println(&quot;Log-likelihood: &quot;, result.loglik)

# Extract smoothed factors
model = StateSpaceModel(spec, result.θ, size(yields, 2))
kalman_filter!(model, yields)
kalman_smoother!(model)
smooth = smoothed_states(model)</code></pre><p><strong>Notes</strong></p><ul><li>Requires spec to have <code>:Z</code> in <code>matrix_exprs</code> as a <code>MatrixExpr</code></li><li>Works best with full T and Q structures (<code>:full</code>) for EM estimation</li><li>Warm-starting significantly improves speed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/em.jl#L1507-L1565">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.DSL.ProfileEMResult"><a class="docstring-binding" href="#Siphon.DSL.ProfileEMResult"><code>Siphon.DSL.ProfileEMResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ProfileEMResult{T&lt;:Real, NT&lt;:NamedTuple}</code></pre><p>Result from profile EM estimation where some parameters are optimized via grid search (profile likelihood) while others use EM closed-form updates.</p><p><strong>Fields</strong></p><ul><li><code>λ_optimal::T</code>: Optimal value of profiled parameter</li><li><code>θ::NT</code>: All parameter estimates at optimum (NamedTuple)</li><li><code>loglik::T</code>: Log-likelihood at optimum</li><li><code>em_result</code>: Full EM result at best λ (NamedTuple)</li><li><code>λ_grid::Vector{T}</code>: Grid of λ values searched</li><li><code>loglik_profile::Vector{T}</code>: Profile log-likelihood at each grid point</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">spec = dns_model(maturities; T_structure=:full, Q_structure=:full)
result = profile_em_ssm(spec, yields; λ_grid=0.01:0.01:0.2)

# Best λ
result.λ_optimal

# All parameters
result.θ  # NamedTuple with λ, T elements, H elements, Q elements

# Profile likelihood plot data
plot(result.λ_grid, result.loglik_profile)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/em.jl#L1469-L1497">source</a></section></details></article><h2 id="Initial-State-Conventions-and-MARSS-Compatibility"><a class="docs-heading-anchor" href="#Initial-State-Conventions-and-MARSS-Compatibility">Initial State Conventions and MARSS Compatibility</a><a id="Initial-State-Conventions-and-MARSS-Compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-State-Conventions-and-MARSS-Compatibility" title="Permalink"></a></h2><p>Siphon.jl internally uses the <code>tinitx=1</code> convention where <code>(a₁, P₁)</code> represents the initial state distribution at time t=1. Both <code>profile_em_ssm</code> and <code>DynamicFactorModel</code> support the <code>tinitx</code> parameter to control how the initial state covariance is computed.</p><p>For a comprehensive explanation of initial state conventions, see the <a href="../tutorials/initial_state.html">Initial State Tutorial</a>.</p><h3 id="The-tinitx-Parameter"><a class="docs-heading-anchor" href="#The-tinitx-Parameter">The <code>tinitx</code> Parameter</a><a id="The-tinitx-Parameter-1"></a><a class="docs-heading-anchor-permalink" href="#The-tinitx-Parameter" title="Permalink"></a></h3><p>The <code>tinitx</code> parameter controls when the initial state covariance <code>V0</code> is defined:</p><table><tr><th style="text-align: right">Setting</th><th style="text-align: right">V0 Interpretation</th><th style="text-align: right">P1 Computation</th></tr><tr><td style="text-align: right"><code>tinitx=0</code> (default)</td><td style="text-align: right">Covariance at t=0</td><td style="text-align: right"><code>P1 = T × V0 × T&#39; + R × Q × R&#39;</code></td></tr><tr><td style="text-align: right"><code>tinitx=1</code></td><td style="text-align: right">Covariance at t=1</td><td style="text-align: right"><code>P1 = V0</code> (no transformation)</td></tr></table><p>With <code>tinitx=0</code>, the initial covariance incorporates one step of state dynamics, matching MARSS&#39;s default behavior.</p><h3 id="The-V0-Parameter"><a class="docs-heading-anchor" href="#The-V0-Parameter">The <code>V0</code> Parameter</a><a id="The-V0-Parameter-1"></a><a class="docs-heading-anchor-permalink" href="#The-V0-Parameter" title="Permalink"></a></h3><p>The <code>V0</code> parameter specifies the initial state covariance value:</p><ul><li><strong>Scalar:</strong> <code>V0=100.0</code> creates <code>V0 × I</code> (identity scaled by V0)</li><li><strong>Matrix:</strong> Can also pass a full covariance matrix (for <code>profile_em_ssm</code>)</li></ul><p><strong>Default:</strong> <code>V0=100.0</code> (MARSS default)</p><h3 id="Usage-Examples"><a class="docs-heading-anchor" href="#Usage-Examples">Usage Examples</a><a id="Usage-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-Examples" title="Permalink"></a></h3><pre><code class="language-julia hljs"># DNS models via profile_em_ssm
result = profile_em_ssm(spec, y; tinitx=0, V0=100.0)  # Default: MARSS-style
result = profile_em_ssm(spec, y; tinitx=1, V0=1e7)    # Diffuse prior at t=1

# Dynamic Factor Models
model = DynamicFactorModel(N, k, n; tinitx=0, V0=100.0)  # Default: MARSS-style
model = DynamicFactorModel(N, k, n; tinitx=1, V0=1e7)    # Diffuse prior at t=1</code></pre><h3 id="Choosing-tinitx-and-V0"><a class="docs-heading-anchor" href="#Choosing-tinitx-and-V0">Choosing <code>tinitx</code> and <code>V0</code></a><a id="Choosing-tinitx-and-V0-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-tinitx-and-V0" title="Permalink"></a></h3><table><tr><th style="text-align: right">Use Case</th><th style="text-align: right">Recommended Setting</th></tr><tr><td style="text-align: right">Match MARSS default</td><td style="text-align: right"><code>tinitx=0, V0=100.0</code></td></tr><tr><td style="text-align: right">Diffuse prior (large uncertainty)</td><td style="text-align: right"><code>tinitx=1, V0=1e7</code></td></tr><tr><td style="text-align: right">Informative prior at t=1</td><td style="text-align: right"><code>tinitx=1, V0=&lt;your value&gt;</code></td></tr><tr><td style="text-align: right">Short time series</td><td style="text-align: right"><code>tinitx=0</code> (accounts for dynamics)</td></tr></table><p><strong>Note:</strong> With <code>tinitx=0</code>, very large <code>V0</code> values (e.g., 1e7) may cause numerical instability because the transformation <code>T × V0 × T&#39;</code> amplifies values. Use <code>tinitx=1</code> with large <code>V0</code> for diffuse priors.</p><h3 id="Initial-State-Updating-in-EM-(update_initial_state)"><a class="docs-heading-anchor" href="#Initial-State-Updating-in-EM-(update_initial_state)">Initial State Updating in EM (<code>update_initial_state</code>)</a><a id="Initial-State-Updating-in-EM-(update_initial_state)-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-State-Updating-in-EM-(update_initial_state)" title="Permalink"></a></h3><p>By default, <code>(a₁, P₁)</code> remains <strong>fixed</strong> throughout EM iterations. Set <code>update_initial_state=true</code> to update them at each M-step using smoothed state estimates:</p><pre><code class="language-julia hljs"># For profile EM (DNS models)
result = profile_em_ssm(spec, y; update_initial_state=true)

# For high-level API
fit!(EM(), model, y; update_initial_state=true)</code></pre><p><strong>How it works:</strong></p><table><tr><th style="text-align: right">EM Iteration</th><th style="text-align: right">With <code>update_initial_state=false</code> (default)</th><th style="text-align: right">With <code>update_initial_state=true</code></th></tr><tr><td style="text-align: right">0 (start)</td><td style="text-align: right"><code>a1</code>, <code>P1</code> from <code>tinitx</code>/<code>V0</code></td><td style="text-align: right"><code>a1</code>, <code>P1</code> from <code>tinitx</code>/<code>V0</code></td></tr><tr><td style="text-align: right">1</td><td style="text-align: right">Same <code>a1</code>, <code>P1</code></td><td style="text-align: right">Updated from smoother</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">Same <code>a1</code>, <code>P1</code></td><td style="text-align: right">Updated from smoother</td></tr><tr><td style="text-align: right">...</td><td style="text-align: right">Same <code>a1</code>, <code>P1</code></td><td style="text-align: right">Updated from smoother</td></tr></table><p>When <code>update_initial_state=true</code>, after each E-step:</p><pre><code class="nohighlight hljs">a₁_new = E[α₁ | y₁:n]      (smoothed state mean at t=1)
P₁_new = Var[α₁ | y₁:n]    (smoothed state covariance at t=1)</code></pre><p><strong>When to use <code>update_initial_state=true</code>:</strong></p><ul><li>Short time series where t=1 significantly affects the likelihood</li><li>Comparing results with MARSS R package</li><li>Estimating the unconditional mean/variance of the state process</li></ul><p><strong>When to keep fixed (default):</strong></p><ul><li>Using a diffuse prior</li><li>Long time series where initial state has negligible effect</li><li>Numerical stability concerns</li></ul><p>The final initial state estimates are returned in <code>EMResult.a1</code> and <code>EMResult.P1</code>.</p><h2 id="Parameter-Transformations"><a class="docs-heading-anchor" href="#Parameter-Transformations">Parameter Transformations</a><a id="Parameter-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Transformations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Siphon.DSL.build_transformation"><a class="docstring-binding" href="#Siphon.DSL.build_transformation"><code>Siphon.DSL.build_transformation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">build_transformation(spec::SSMSpec)</code></pre><p>Build a TransformVariables transformation from an SSMSpec.</p><p>Returns a transformation that maps ℝⁿ → NamedTuple with the parameter names and appropriate constraints (positive for variances, bounded for others).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">spec = local_level()
t = build_transformation(spec)
# t transforms ℝ² → (σ_obs = ..., σ_level = ...)

θ_nt = transform(t, randn(2))
# θ_nt is a NamedTuple with positive values</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/codegen.jl#L22-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.DSL.transform_to_constrained"><a class="docstring-binding" href="#Siphon.DSL.transform_to_constrained"><code>Siphon.DSL.transform_to_constrained</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transform_to_constrained(spec, θ_unconstrained)</code></pre><p>Transform from unconstrained ℝⁿ to constrained parameter space. Returns (θ_constrained::NamedTuple, logjac::Real).</p><p>Uses TransformVariables.jl for the transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/bayesian.jl#L27-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.DSL.transform_to_unconstrained"><a class="docstring-binding" href="#Siphon.DSL.transform_to_unconstrained"><code>Siphon.DSL.transform_to_unconstrained</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transform_to_unconstrained(spec, θ_constrained::NamedTuple)</code></pre><p>Transform from constrained NamedTuple to unconstrained ℝⁿ. Inverse of <code>transform_to_constrained</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/bayesian.jl#L41-L46">source</a></section><section><div><pre><code class="language-julia hljs">transform_to_unconstrained(spec, θ_constrained::AbstractVector)</code></pre><p>Transform from constrained vector to unconstrained ℝⁿ. First converts vector to NamedTuple, then inverts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/bayesian.jl#L52-L57">source</a></section></details></article><h2 id="Log-Density-Interface"><a class="docs-heading-anchor" href="#Log-Density-Interface">Log-Density Interface</a><a id="Log-Density-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Log-Density-Interface" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Siphon.DSL.SSMLogDensity"><a class="docstring-binding" href="#Siphon.DSL.SSMLogDensity"><code>Siphon.DSL.SSMLogDensity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SSMLogDensity(spec, y; prior=nothing, use_static=true)</code></pre><p>Log-density for a state-space model, evaluated in UNCONSTRAINED ℝⁿ space.</p><p>This integrates seamlessly with LogDensityProblems.jl for optimization and sampling. The transformation from unconstrained to constrained space is handled automatically using TransformVariables.jl.</p><p><strong>Fields</strong></p><ul><li><code>spec</code>: Model specification (SSMSpec)</li><li><code>transformation</code>: TransformVariables transformation (ℝⁿ → NamedTuple)</li><li><code>y</code>: Observation data (p × n matrix)</li><li><code>prior</code>: Optional prior on CONSTRAINED parameters (θ::NamedTuple -&gt; log_prior)</li><li><code>use_static</code>: Whether to use StaticArrays for small matrices (default: true)</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">spec = local_level()
y = randn(1, 100)

# Create log-density (works in unconstrained space)
ld = SSMLogDensity(spec, y)

# Get initial point in unconstrained space
θ0 = transform_to_unconstrained(spec, initial_values(spec))

# Evaluate log-density
logdensity(ld, θ0)

# For optimization (in unconstrained space, no bounds needed!)
using Optim
result = optimize(θ -&gt; -logdensity(ld, θ), θ0, LBFGS())

# Transform result back to NamedTuple
θ_hat, _ = transform_to_constrained(spec, result.minimizer)
# θ_hat is a NamedTuple like (σ_obs = 12.3, σ_level = 3.4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/bayesian.jl#L69-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.DSL.logdensity"><a class="docstring-binding" href="#Siphon.DSL.logdensity"><code>Siphon.DSL.logdensity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logdensity(ld::SSMLogDensity, θ_unconstrained)</code></pre><p>Evaluate the log-density at unconstrained parameters.</p><p>Returns log p(y|θ) + log p(θ) + log|J| where J is the Jacobian of the transformation from unconstrained to constrained space.</p><p>The parameters are automatically transformed to a NamedTuple and passed to the likelihood function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/bayesian.jl#L122-L132">source</a></section></details></article><h2 id="Prior-Distributions"><a class="docs-heading-anchor" href="#Prior-Distributions">Prior Distributions</a><a id="Prior-Distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Prior-Distributions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Siphon.DSL.FlatPrior"><a class="docstring-binding" href="#Siphon.DSL.FlatPrior"><code>Siphon.DSL.FlatPrior</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FlatPrior()</code></pre><p>Improper flat prior (log-density = 0 everywhere). Works with both Vector and NamedTuple arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/bayesian.jl#L168-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.DSL.NormalPrior"><a class="docstring-binding" href="#Siphon.DSL.NormalPrior"><code>Siphon.DSL.NormalPrior</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NormalPrior(μ::NamedTuple, σ::NamedTuple)</code></pre><p>Independent normal priors for parameters, specified by name.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">prior = NormalPrior(
    (σ_obs = 10.0, σ_level = 5.0),   # means
    (σ_obs = 5.0, σ_level = 2.0)     # standard deviations
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/bayesian.jl#L177-L189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.DSL.InverseGammaPrior"><a class="docstring-binding" href="#Siphon.DSL.InverseGammaPrior"><code>Siphon.DSL.InverseGammaPrior</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InverseGammaPrior(α, β, param_names)</code></pre><p>Inverse gamma priors for variance parameters at specified parameter names. Assumes θ contains standard deviations (will square them).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">prior = InverseGammaPrior(2.0, 1.0, (:σ_obs, :σ_level))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/bayesian.jl#L230-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Siphon.DSL.CompositePrior"><a class="docstring-binding" href="#Siphon.DSL.CompositePrior"><code>Siphon.DSL.CompositePrior</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompositePrior(priors...)</code></pre><p>Combine multiple priors by summing their log-densities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gragusa/Siphon.jl/blob/34835432622d5887b498d029e738893bc78078f6/src/dsl/bayesian.jl#L257-L261">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="matrix_helpers.html">« Matrix Helpers</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 25 January 2026 19:05">Sunday 25 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
