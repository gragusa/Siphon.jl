"""
DNS Model Validation Tests Against MARSS R Package.

Tests the Dynamic Nelson-Siegel implementation in Siphon.jl against reference values
computed by MARSS (Multivariate Autoregressive State-Space) R package.

Reference files generated by: test/marss_dns_reference.R
"""

using Test
using Siphon
using Siphon.DSL
using LinearAlgebra
using DelimitedFiles

# Helper function to load MARSS results CSV
function load_marss_results(filename)
    data = readdlm(joinpath(@__DIR__, filename), ','; header = true)[1]
    result = Dict{String,Float64}()
    for i = 1:size(data, 1)
        param_name = String(data[i, 1])
        param_value = Float64(data[i, 2])
        result[param_name] = param_value
    end
    return result
end

# ============================================
# Test 1: DNS Loading Functions
# ============================================

@testset "DNS Loading Functions" begin
    @testset "dns_loading1 - Slope loading" begin
        # Test formula: (1 - exp(-λτ)) / (λτ)
        λ = 0.0609

        for τ in [3, 12, 24, 60, 120]
            x = λ * τ
            expected = (1 - exp(-x)) / x
            @test Siphon.dns_loading1(λ, τ) ≈ expected atol=1e-10
        end
    end

    @testset "dns_loading2 - Curvature loading" begin
        # Test formula: (1 - exp(-λτ)) / (λτ) - exp(-λτ)
        λ = 0.0609

        for τ in [3, 12, 24, 60, 120]
            x = λ * τ
            slope = (1 - exp(-x)) / x
            expected = slope - exp(-x)
            @test Siphon.dns_loading2(λ, τ) ≈ expected atol=1e-10
        end
    end

    @testset "Numerical stability for small λτ" begin
        # For very small λτ, the formula should still work
        λ = 1e-12
        τ = 1.0

        # Should use Taylor expansion: 1 - x/2 for very small x
        @test Siphon.dns_loading1(λ, τ) ≈ 1.0 atol=1e-6
        @test Siphon.dns_loading2(λ, τ) ≈ 0.0 atol=1e-6
    end

    @testset "Z matrix matches MARSS" begin
        # Load MARSS Z matrix
        z_data = readdlm(joinpath(@__DIR__, "marss_dns_Z.csv"), ','; header = true)[1]
        maturities = Int.(z_data[:, 1])
        Z_marss = z_data[:, 2:4]

        λ = 0.0609
        p = length(maturities)

        # Build Z matrix using Siphon
        Z_siphon = ones(p, 3)
        for i = 1:p
            Z_siphon[i, 2] = Siphon.dns_loading1(λ, maturities[i])
            Z_siphon[i, 3] = Siphon.dns_loading2(λ, maturities[i])
        end

        # Compare
        @test Z_siphon ≈ Z_marss atol=1e-4
    end
end

# ============================================
# Test 2: Log-likelihood Match at MARSS Parameters
# ============================================

@testset "DNS Log-likelihood - MARSS Validation" begin
    # Load reference data and results
    data = readdlm(joinpath(@__DIR__, "marss_dns_data.csv"), ',', Float64; header = true)[1]
    y = Matrix(data')  # Convert to p × n

    p, n = size(y)
    m = 3  # number of states

    results_diag = load_marss_results("marss_dns_diag_results.csv")
    λ = results_diag["lambda"]
    maturities = [3, 12, 24, 60, 120]

    # Build Z matrix at MARSS lambda
    Z = ones(p, m)
    for i = 1:p
        Z[i, 2] = Siphon.dns_loading1(λ, maturities[i])
        Z[i, 3] = Siphon.dns_loading2(λ, maturities[i])
    end

    # Build T matrix from MARSS estimates (diagonal)
    T = diagm([results_diag["B_L"], results_diag["B_S"], results_diag["B_C"]])

    # Build Q matrix from MARSS estimates (diagonal)
    Q = diagm([results_diag["Q_L"], results_diag["Q_S"], results_diag["Q_C"]])

    # Build H matrix from MARSS estimates (diagonal)
    # Note: MARSS R_i corresponds to our H_ii
    H = diagm([
        results_diag["R_1"],
        results_diag["R_2"],
        results_diag["R_3"],
        results_diag["R_4"],
        results_diag["R_5"],
    ])

    # Handle zero variance (MARSS sometimes estimates exactly 0)
    # Replace with small positive value to avoid numerical issues
    for i = 1:p
        if H[i, i] < 1e-10
            H[i, i] = 1e-10
        end
    end

    # R matrix (selection) is identity for DNS
    R = Matrix(1.0I, m, m)

    # Initial state (MARSS uses tinitx=0, V0=100*I)
    # Convert to Siphon convention: a1 = T*x0, P1 = T*V0*T' + R*Q*R'
    x0 = zeros(m)
    V0 = 100.0 * Matrix(1.0I, m, m)
    a1 = T * x0  # = zeros(m)
    P1 = T * V0 * T' + R * Q * R'

    # Build KFParms and compute log-likelihood
    kfp = KFParms(Z, H, T, R, Q)
    ll_siphon = kalman_loglik(kfp, y, a1, P1)
    ll_marss = results_diag["loglik"]

    println("\nLog-likelihood comparison (diagonal model at MARSS params):")
    println("  Siphon: $ll_siphon")
    println("  MARSS:  $ll_marss")
    println("  Diff:   $(ll_siphon - ll_marss)")

    # Log-likelihood should match within tolerance
    # Note: Small differences expected due to:
    # 1. Initial state convention differences
    # 2. Numerical precision
    # 3. H diagonal elements set to 1e-10 instead of 0
    @test isapprox(ll_siphon, ll_marss, rtol = 0.01)
end

# ============================================
# Test 3: EM Estimation - Diagonal Structure
# ============================================

@testset "DNS EM - Diagonal Structure - MARSS Validation" begin
    # Load reference data
    data = readdlm(joinpath(@__DIR__, "marss_dns_data.csv"), ',', Float64; header = true)[1]
    y = Matrix(data')

    p, n = size(y)
    m = 3

    results = load_marss_results("marss_dns_diag_results.csv")
    λ_fixed = results["lambda"]
    maturities = [3, 12, 24, 60, 120]

    # Build Z at fixed lambda
    Z = ones(p, m)
    for i = 1:p
        Z[i, 2] = Siphon.dns_loading1(λ_fixed, maturities[i])
        Z[i, 3] = Siphon.dns_loading2(λ_fixed, maturities[i])
    end

    # Initialize T closer to MARSS estimates
    T_init = diagm([results["B_L"], results["B_S"], results["B_C"]])
    R = Matrix(1.0I, m, m)

    # Initialize H closer to MARSS (avoid zeros by using small positive values)
    H_diag = [max(results["R_$i"], 1e-6) for i = 1:p]
    H_init = diagm(H_diag)

    # Initialize Q closer to MARSS
    Q_init = diagm([results["Q_L"], results["Q_S"], results["Q_C"]])

    # Initial state - use diffuse prior
    a1 = zeros(m)
    P1 = 100.0 * Matrix(1.0I, m, m)

    # Run general EM (with diagonal constraints via free masks)
    em_result = Siphon.DSL._em_general_ssm_full_cov(
        Float64.(Z),
        T_init,
        Float64.(R),
        H_init,
        Q_init,
        y,
        a1,
        P1;
        Z_free = falses(p, m),      # Z is fixed
        T_free = Matrix(I(m)) .== 1, # Only diagonal T elements
        H_free = Matrix(I(p)) .== 1, # Only diagonal H elements
        Q_free = Matrix(I(m)) .== 1, # Only diagonal Q elements
        maxiter = 2000,
        tol_ll = 1e-8,
        tol_param = 1e-6,
        verbose = false,
    )

    println("\nJulia DNS EM Results (Diagonal):")
    println("================================")
    println("T_L = $(em_result.T[1,1]) (MARSS: $(results["B_L"]))")
    println("T_S = $(em_result.T[2,2]) (MARSS: $(results["B_S"]))")
    println("T_C = $(em_result.T[3,3]) (MARSS: $(results["B_C"]))")
    println("Q_L = $(em_result.Q[1,1]) (MARSS: $(results["Q_L"]))")
    println("Q_S = $(em_result.Q[2,2]) (MARSS: $(results["Q_S"]))")
    println("Q_C = $(em_result.Q[3,3]) (MARSS: $(results["Q_C"]))")
    for i = 1:p
        println("H_$i = $(em_result.H[i,i]) (MARSS: $(results["R_$i"]))")
    end
    println("loglik = $(em_result.loglik) (MARSS: $(results["loglik"]))")
    println("iterations = $(em_result.iterations)")
    println("converged = $(em_result.converged)")

    # Test transition matrix (T) estimates
    @test isapprox(em_result.T[1, 1], results["B_L"], rtol = 0.05)
    @test isapprox(em_result.T[2, 2], results["B_S"], rtol = 0.05)
    @test isapprox(em_result.T[3, 3], results["B_C"], rtol = 0.05)

    # Test state covariance (Q) estimates
    @test isapprox(em_result.Q[1, 1], results["Q_L"], rtol = 0.10)  # Looser for Q
    @test isapprox(em_result.Q[2, 2], results["Q_S"], rtol = 0.10)
    @test isapprox(em_result.Q[3, 3], results["Q_C"], rtol = 0.10)

    # Test log-likelihood
    @test isapprox(em_result.loglik, results["loglik"], rtol = 0.001)

    # Siphon should achieve at least as good log-likelihood as MARSS
    @test em_result.loglik >= results["loglik"] - 1.0  # Allow some tolerance for numerical issues
end

# ============================================
# Test 4: EM Estimation - Full Structure
# ============================================

@testset "DNS EM - Full Structure - MARSS Validation" begin
    # Load reference data
    data = readdlm(joinpath(@__DIR__, "marss_dns_data.csv"), ',', Float64; header = true)[1]
    y = Matrix(data')

    p, n = size(y)
    m = 3

    results = load_marss_results("marss_dns_full_results.csv")
    λ_fixed = results["lambda"]
    maturities = [3, 12, 24, 60, 120]

    # Build Z at fixed lambda
    Z = ones(p, m)
    for i = 1:p
        Z[i, 2] = Siphon.dns_loading1(λ_fixed, maturities[i])
        Z[i, 3] = Siphon.dns_loading2(λ_fixed, maturities[i])
    end

    # Initial values (start closer to MARSS estimates for faster convergence)
    T_init = 0.9 * Matrix(1.0I, m, m)
    R = Matrix(1.0I, m, m)
    H_init = 0.01 * Matrix(1.0I, p, p)
    Q_init = 0.1 * Matrix(1.0I, m, m)

    # Initial state
    a1 = zeros(m)
    P1 = T_init * 100.0 * Matrix(1.0I, m, m) * T_init' + R * Q_init * R'

    # Run general EM with full T and Q
    em_result = Siphon.DSL._em_general_ssm_full_cov(
        Float64.(Z),
        T_init,
        Float64.(R),
        H_init,
        Q_init,
        y,
        a1,
        P1;
        Z_free = falses(p, m),      # Z is fixed
        T_free = trues(m, m),       # Full T
        H_free = Matrix(I(p)) .== 1, # Diagonal H (as in MARSS)
        Q_free = trues(m, m),       # Full Q
        maxiter = 2000,
        tol_ll = 1e-8,
        tol_param = 1e-6,
        verbose = false,
    )

    # Extract MARSS T matrix estimates
    T_marss = [
        results["B_1_1"] results["B_1_2"] results["B_1_3"];
        results["B_2_1"] results["B_2_2"] results["B_2_3"];
        results["B_3_1"] results["B_3_2"] results["B_3_3"]
    ]

    # Extract MARSS Q matrix estimates
    Q_marss = [
        results["Q_1_1"] results["Q_1_2"] results["Q_1_3"];
        results["Q_2_1"] results["Q_2_2"] results["Q_2_3"];
        results["Q_3_1"] results["Q_3_2"] results["Q_3_3"]
    ]

    println("\nJulia DNS EM Results (Full):")
    println("============================")
    println("T matrix:")
    display(round.(em_result.T, digits = 4))
    println("\nMARSS T matrix:")
    display(round.(T_marss, digits = 4))
    println("\nQ matrix:")
    display(round.(em_result.Q, digits = 4))
    println("\nMARSS Q matrix:")
    display(round.(Q_marss, digits = 4))
    println("\nloglik = $(em_result.loglik) (MARSS: $(results["loglik"]))")
    println("iterations = $(em_result.iterations)")
    println("converged = $(em_result.converged)")

    # Test T matrix (looser tolerance for full matrix)
    @test isapprox(em_result.T, T_marss, rtol = 0.10)

    # Test Q matrix
    @test isapprox(em_result.Q, Q_marss, rtol = 0.15)  # Covariances harder to estimate

    # Test log-likelihood (primary metric)
    @test isapprox(em_result.loglik, results["loglik"], rtol = 0.005)

    # Siphon should achieve comparable log-likelihood
    @test em_result.loglik >= results["loglik"] - 5.0
end

# ============================================
# Test 5: EM Estimation - Scalar H Structure
# ============================================

@testset "DNS EM - Scalar H - MARSS Validation" begin
    # Load reference data
    data = readdlm(joinpath(@__DIR__, "marss_dns_data.csv"), ',', Float64; header = true)[1]
    y = Matrix(data')

    p, n = size(y)
    m = 3

    results = load_marss_results("marss_dns_scalar_results.csv")
    λ_fixed = results["lambda"]
    maturities = [3, 12, 24, 60, 120]

    # Build Z at fixed lambda
    Z = ones(p, m)
    for i = 1:p
        Z[i, 2] = Siphon.dns_loading1(λ_fixed, maturities[i])
        Z[i, 3] = Siphon.dns_loading2(λ_fixed, maturities[i])
    end

    # For scalar H, use low-level EM with all H diagonal elements set to same value
    # Initialize at MARSS estimates
    T_init = diagm([results["B_L"], results["B_S"], results["B_C"]])
    R = Matrix(1.0I, m, m)
    H_init = results["R_scalar"] * Matrix(1.0I, p, p)  # Scalar H = σ² * I
    Q_init = diagm([results["Q_L"], results["Q_S"], results["Q_C"]])

    a1 = zeros(m)
    P1 = 100.0 * Matrix(1.0I, m, m)

    # For scalar H constraint, we need a special H_free mask where all elements
    # are linked to a single scalar. The current EM doesn't support this directly,
    # so we'll verify the log-likelihood at MARSS values instead.

    # Compute log-likelihood at MARSS scalar H parameters
    kfp = KFParms(Z, H_init, T_init, R, Q_init)
    ll_siphon = kalman_loglik(kfp, y, a1, P1)
    ll_marss = results["loglik"]

    println("\nScalar H Log-likelihood comparison:")
    println("  Siphon: $ll_siphon")
    println("  MARSS:  $ll_marss")
    println("  Diff:   $(ll_siphon - ll_marss)")

    # Log-likelihood should match at MARSS parameters
    @test isapprox(ll_siphon, ll_marss, rtol = 0.001)

    # Also verify the scalar H model makes sense: MARSS parameters
    println("\nMARSS Scalar H parameters:")
    println("  T = $(diag(T_init))")
    println("  Q = $(diag(Q_init))")
    println("  H (scalar) = $(results["R_scalar"])")
end

# ============================================
# Test 6: DNS Template and Profile EM
# ============================================

@testset "DNS Profile EM - Grid Search" begin
    # Load reference data
    data = readdlm(joinpath(@__DIR__, "marss_dns_data.csv"), ',', Float64; header = true)[1]
    y = Matrix(data')

    maturities = [3, 12, 24, 60, 120]

    # Create DNS spec
    spec = dns_model(
        maturities;
        T_structure = :diagonal,
        H_structure = :diagonal,
        Q_structure = :diagonal,
        λ_init = 0.06,
        diffuse = false,
    )

    # Run profile EM with grid search over lambda
    result =
        profile_em_ssm(spec, y; λ_grid = 0.04:0.01:0.10, verbose = false, maxiter = 200)

    println("\nProfile EM Results:")
    println("==================")
    println("Optimal λ = $(result.λ_optimal)")
    println("Log-likelihood at optimal λ = $(result.loglik)")
    println("λ grid profile:")
    for (λ, ll) in zip(result.λ_grid, result.loglik_profile)
        println("  λ = $(round(λ, digits=3)), loglik = $(round(ll, digits=2))")
    end

    # The optimal lambda should be in reasonable range
    @test 0.03 < result.λ_optimal < 0.15

    # Profile likelihood should have reasonable values
    @test all(isfinite.(result.loglik_profile))

    # Optimal should be best on grid
    @test result.loglik ≈ maximum(result.loglik_profile)
end
